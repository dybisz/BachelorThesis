\documentclass{article}

\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage{longtable}
%\usepackage[export]{adjustbox}
%\usepackage{tabu}
\usepackage{xcolor,colortbl}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}

\begin{document}

\vspace*{3ex}
\begin{flushright}
{\large 27 October 2015}
\end{flushright}

\vskip20ex
\hskip3cm

\begin{center}


\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{images/mini.png}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{images/pw.jpg}
\end{subfigure}
\end{figure}




\Large {\bf
	Bachelor Thesis \\
	Finite Automata for Pattern Recognition
}

\Large {\bf 
	Requirement specification 
}
\end{center}
\vskip2ex


\vskip25ex

\begin{flushleft}
{\large Bartlomiej Dybisz \\
Jakub Ciecierski

}
\end{flushleft}

\newpage
\tableofcontents
\newpage

%------------------------------------------------------------------------------

\section*{Document metric}


\begin{table}[h]
\hspace*{-4.1cm}
\large
\begin{tabular}{|
>{\columncolor[HTML]{C0C0C0}}l |l|l|l|l|l|}
\hline
\multicolumn{6}{|l|}{\cellcolor[HTML]{C0C0C0}Document metric}                                                                                                                                         \\ \hline
Project:       & \multicolumn{2}{l|}{Finite automata for pattern recognition} & 
\cellcolor[HTML]{C0C0C0}Company: & \multicolumn{2}{l|}{WUT}                                               \\ \hline
Name:          & \multicolumn{5}{l|}{Requirement specification}                                                                                                                                       \\ \hline
Topics:        & \multicolumn{5}{l|}{Business analysis of the product}                                                                                                                                       \\ \hline
Author:        & \multicolumn{5}{l|}{Jakub Ciecierski, Bartlomiej Dybisz}                                                                                                                                                \\ \hline
File:          & \multicolumn{5}{l|}{requirement\_specification.pdf}                                                                                                                                      \\ \hline
Version no:    & 0.1                                                                      & \cellcolor[HTML]{C0C0C0}Status:  & Under development & \cellcolor[HTML]{C0C0C0}Opening date: & 2015-10-27 \\ \hline
Summary:       & \multicolumn{5}{l|}{Business analysis of research on pattern recognition by finite automata}                                                                                                           \\ \hline
Authorized by: & \begin{tabular}[c]{@{}l@{}}Wladyslaw Homenda\end{tabular} & \multicolumn{3}{l|}{\cellcolor[HTML]{C0C0C0}Last modification date:}                         & 2015-10-27 \\ \hline
\end{tabular}
\end{table}



\section*{History of changes}

\begin{table}[h]
\hspace*{-4.1cm}
\large
\begin{tabular}{|l|l|l|l|}
\hline
\multicolumn{4}{|l|}{\cellcolor[HTML]{C0C0C0}History of Changes} \\ \hline
Version         & Date         & Who        & Description        \\ \hline

0.1         
& 2015-10-27         
& Jakub Ciecierski, Bartlomiej Dybisz
& Definition of the main purpose of the document       \\ \hline
\end{tabular}
\end{table}

%---------------------------------------------------------------

\section*{Schedule}

\begin{table}[h]
\centering
\hspace*{-4.1cm}
\large
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|l|}{\cellcolor[HTML]{C0C0C0}Schedule} \\ \hline
Date         & Note        & Planned Progress          \\ \hline

27.10.2015   & Lab1    & Presentation of Business Analysis   \\ \hline
03.11.2015   &    & Additional changes of Business Analysis   \\ \hline
7-9.11.2015   &     & First drafts of UML of particular modules   \\ \hline
14-16.11.2015   &     & Requirements analysis, design of algorithms and further UMML development \\ \hline
17.11.2015   &  Lab2   & Presentation of Technical Analysis   \\ \hline
20-22.11.2015   &     & Implementation of mudules needed for testing and basic GUI   \\ \hline
31.11.2015   & Lab3    & Presentation of results of tests on synthetic and semi-synthetic data  \\ \hline
4-6.12.2015   &     & GUI and console application development  \\ \hline
15.12.2015   & Lab4    & Final GUI  \\ \hline
-------  & -------    & Work depends on acquired results  \\ \hline
08.01.2015  & Lab5    & Complete system presentation  \\ \hline
\end{tabular}
\end{table}

%---------------------------------------------------------------



\newpage
\section{Glossary}


%---------------------------------------------------------------
%---------------------------------------------------------------

\begin{itemize}

\item  {\bf Pattern Recognition}
In broad terms, pattern recognition is science of making assumptions about data using various tools from statistics, machine learning and many others fields.
Focuses on designing and building machines that can recognize patterns. Such patterns can be found in speech, fingerprint, optical characters etc.

Feature is defined as a quality or characteristic of an element.
Such feature can be a symbolic measure (e.g. color) or numeric (e.g. width).
Collection of $d$ features is called a $d$-dimensional feature vector.

In classification a pattern can be represented by a pair $(x,w)$ where $x$ is the feature vector and $w$ is label. A label tells the computer to which class a given element belongs to. Elements from the same class should have similar features, while elements belonging to different classes should have relatively different features.

%---------------------------------------------------------------
%---------------------------------------------------------------

\item {\bf Alphabet}
Is a finite, non empty set of symbols, commonly denoted by $\Sigma$.
Examples of common alphabets:
\begin{enumerate}
	\item $\Sigma$ = $\{0 ,1 \}$ - binary alphabet.
	\item $\Sigma$ = $\{a, b, ..., z\}$ - small letters of latin alphabet.
\end{enumerate}

%---------------------------------------------------------------
%---------------------------------------------------------------

\item {\bf Word over Alphabet}
Also called a \textit{string}, is a sequence of symbols over some alphabet $\Sigma$.
Examples of words:
\begin{enumerate}
	\item A sequence $'01010'$ is a word over binary alphabet $\Sigma=\{0,1\}$.
	\item A word $'lorem'$ is a word over the latin alphabet $\Sigma=\{a, b, ..., z\}$.
\end{enumerate}

An empty word is a word with no symbols. Commonly denoted by $\varepsilon$. Such word can be taken from any alphabet.

A set of all words over alphabet $\Sigma$ is denoted by $\Sigma^*$,
where 
\begin{equation}
\Sigma^* = \Sigma^0 \cup \Sigma^1 \cup \Sigma^2 \cup \Sigma^3 \cup ...
\end{equation}

If $\Sigma = \{0,1\}$
then $\Sigma^0 = \{\varepsilon \}$, $\Sigma^1 = \{0,1\}$ , $\Sigma^2 = \{00, 01 ,10 ,11\}$,
$\Sigma^3 = \{000, 001, 010, 011, 100, 101, 110, 111\}$ and so on

It is important to note that, $\Sigma^*$ is infinite countable set.

%---------------------------------------------------------------
%---------------------------------------------------------------

\item {\bf Language}
Language over alphabet $\Sigma$ will be denoted by L.
Language L is a subset of all words $\Sigma^*$, $L \subseteq \Sigma^*$.

Examples of languages:
\begin{enumerate}

	\item 
	$L = \{\varepsilon, 01, 10, 0011, 0101, 0110, ...\}$ -
	a set of all binary words that have the same number of occurrences of $0's$ 	and $1's$
	
	\item 	$L = \O$ - language is an empty set, contains no words
	
	\item 	$L = \{\varepsilon \}$ - language containing only empty word.

\end{enumerate}


%---------------------------------------------------------------
%---------------------------------------------------------------

\item {\bf Deterministic Finite Automaton (DFA)}
Automaton is a very simply computability model.
It can be thought of as a physical machine containing a \textit{tape} with input word, a \textit{head} reading a single symbol from the tape and finally a steering mechanism which can change its state during the computations based on current state and a symbol that is being read.
DFA computes a word in order to check if a given word belongs to a language accepted by this machine.

Formally DFA is a system of five fields:

\begin{equation}
	A = (Q, \Sigma, \delta, q_0, F)
\end{equation}

where \\
$Q$ - finite set of states. \\
$\Sigma$ - Finite input alphabet. \\
$\delta$ - transition function. $\delta: Q \times \Sigma \rightarrow Q$ \\
$q_0$ - the initial state. $q_0 \in Q$ \\
$F$ - Set of accepting states. $F \subseteq Q$ \\


The computations of DFA is a sequence of transitions based on transition function.
Depending on a state $q$ and symbol $x$ read by the head the machine:
\begin{enumerate}
	\item changes its state to $p \in Q$
	\item moves the head one cell to the right.
\end{enumerate}

Automaton finished computations when all symbols were read. It accepts input if computations end in accepting state, otherwise the input is rejected.



\end{itemize}


\begin{center}
	\begin{figure}[H]
		\begin{center}
		\includegraphics[scale=0.35]{images/automaton.png}
		\end{center}
		\caption{Example of DFA that accepts only binary numbers that are multiples of 3. $S_0$ is the initial and the only accepting state.}
	\end{figure}
\end{center}


%---------------------------------------------------------------

\newpage
\section{Goal}
The main goal of this project is to deploy application, which will create an automaton for given input data. Produced automaton will be a an accurate classifier of objects represented
by the input data. The program is dedicated to research laboratory, hence it is lumbered with the following assumptions.


First of all, all users will be scientists, so precision of calculations and reliability is vital. We want to be sure about results given by the application to such an extent, that they will be publishable. It is also carrying need for specific format of the output - by default latex tables and .xls files. Similarly input is in form of .xls files.


Next thing that we want to stress out is platform and design. As for target system, linux is unquestionable choice. All work stations are running Arch Linux and we want the program to be operable on all of them. Although most of the researchers work inside the laboratory, some of us are using SSH protocol to communicate. This causes the need for plain console application - configurable using flags or simple question/answer scheme. 

But we do not want to limit ourselves only to this approach - finally vast majority of us use computers via the standard X Window System and want to benefit from it. For those who does, we want to present simple GUI based program to configure, run and monitor the process of calculating automata. It will have all functionalities of console part, but will be easier on the eye and simpler to use for non computer scientist.


Last but not least, we will tackle resources consumption and critical situation handling. On this point let us be clear: we want accurate results - neither time nor memory are important. The assumption of course holds to some reasonable extent - we do not want to wait a month for program's output, but we are rather used to wait for couple of days. Great solution in this case would be ability to adjust complexity of calculations and, what follows, time needed to complete. With such an estimation, we could easily schedule our work.

%---------------------------------------------------------------

\newpage
\section{User stories}

%---------------------------------------------------------------
%---------------------------------------------------------------

%
% Console / Default User Stories
%
\subsection{Console}
As a user I want to:
\begin{itemize}
	\item 
		modify configuration file in order to specify computations to my needs.

	\item 
		input specific flags that change corresponding variables saved in the configuration file.
		
	\item 
		specify output log directory path in order to store logs from the computations in desired location.
		
	\item 
		to be able to run many computing processes at once.
	
	\item
		to be able to specify whether my computations shall be restarted automatically in case of a crash.

	\item
		to be able to specify which test bench should be ran after starting the computations.
				

		
\end{itemize}

%---------------------------------------------------------------
%---------------------------------------------------------------

%
% GUI User Stories
%
\subsection{GUI}
As a user I want to:
\begin{itemize}
	\item
		load data using file explorer.
	\item
		load data using drag and drop procedure.
	\item
		adjust computation precision and see estimated time to complete.
	\item
		select output format as .xls file.
	\item
		select output format as latex table.
	\item
		select destination folder of the output
	\item
		decide if test should be rerun in case of failure/interruption.
	\item 
		start computation for loaded data.
	\item
		stop specific computation.
	\item
		stop all computations.
	\item 
		monitor number of currently running computations
	\item
		monitor estimated time of all computations
	\item
		monitor progress of single computation.
	\item
		close application at any time
	\item
		minimize application at any time.
	\item 
		resize application window.
\end{itemize}


	%---------------------------------------------------------------

\newpage

\section{Functional Requirements}
In all tables of the following section we assume that priority can take following values:
\begin{itemize} 
	\item 1 - must be implemented
	\item 2 - can be implemented optionally 
	\item 3 - is a nice addition, but not essential.
\end{itemize} 

%---------------------------------------------------------------
%---------------------------------------------------------------

\subsection{Console} \label{console_func_req}

\begin{center}
\hspace*{-2.1cm}
	\begin{longtable}{| l | p{4cm} | p{3.5cm} | l |}
	
		\hline
	  	ID & Requirement & Comments & Priority \\
		\hline
		
		1 & 
		
		Configuration file should exist, containing all necessary variables in order to tweak the computational process & 
		
		The choice of format of the file is left to the developer &
		 
		1 
		
		\\ \hline
				
		2 & 
		
		Running the computations through the console should allow appliance of flags that override the variables saved in configuration file. & 
		
		The configuration file can be then seen as a set of default values &
		 
		1 
		\\ \hline
		
		2.1 & 
		
		User should be able to choose the test bench which he wants to run.& 
		
		It should be available through both configuration file and by setting a appropriate flag &
		 
		1 
		\\ \hline
		

		3 & 
		
		The output in the console should be clean and readable.
		Each printout can be optionally stamped with the time of the print.& 
		
		&
		 
		1
		\\ \hline
		
		
		3.1 & 
		
		The output log should be also directed to files saved in directory of user's choice.& 
		
		If no directory has been chosen, then the logs shall not be saved to files&
		 
		1
		\\ \hline
		
		
		3.2 & 
		
		The output in the console should use color pallet to make the reading even easier& 
		
		&
		 
		2
		\\ \hline
		

		4 & 
		
		After the computations are finished the time of computing should be printed& 
		
		&
		 
		1
		\\ \hline		
		
	\end{longtable}
\end{center}	


%---------------------------------------------------------------
%---------------------------------------------------------------


\subsection{GUI} \label{GUI_func_req}

\begin{center}
\hspace*{-2.1cm}
	\begin{longtable}{| l | p{4cm} | p{3.5cm} | l |}
	
		\hline
	  	ID & Requirement & Comments & Priority \\
		\hline
		
		1 & 
		The system provides option to load data file using buttun 'Load data' and
		some window explorer to choose a file & 
		 &
		1 
		\\ \hline
		
		1.1 & 
		The system provides area over which one can drag and drop data file.
		Following action will have similar results to requirement of id 1. & 
		 &
		1 
		\\ \hline		
	
		2 & 
		When new data is loaded, one can adjust computation precision via various checkboxes, 			sliders etc. Implementation of this part will depend on used algorithm. & 
		 &
		1 
		\\ \hline		
	
			2.1 & 
		Time estimation indicator, dynamically updated during usage of items from requirement 			of id 2 & 
		 &
		1 
		\\ \hline		
		
		3 & 
		Application will have expanded list with possible output files. Choosing one will 				affect a way of saving result. & 
		 &
		1 
		\\ \hline			

		3.1 & 
		Option of .xls file on list described in 3 & 
		 &
		1 
		\\ \hline		

		3.2 & 
		Option of latex table on list described in 3 & 
		 &
		1 
		\\ \hline	

		4 & 
		System will provide 'Choose Output Folder' button which will open window explorer and 			ask user to choose folder to save result from a test. & 
		 &
		1 
		\\ \hline	
	
		4.1 & 
		Label with path to the output folder, chosen in requirement number 4. & 
		 &
		2 
		\\ \hline		
		
		5 & 
		Opportunity to choose behaviour after crashing of a particular test - rerun or not & 
		 &
		1
		\\ \hline
		
		6 & 
		Button 'Start Computation', which will begin computing automaton for a loaded data. & 
		 &
		1
		\\ \hline		
		
		7 & 
		'Stop Computation' button, for each currently running computation. It will cause 				particular computation to break whatever it is doing right now. & 
		 &
		1
		\\ \hline	
		
		8 & 
		'Stop All Computations' button. All computations break whatever they are doing right 			now. & 
		 &
		1
		\\ \hline		
		
		9 & 
		System will provide a way of monitoring number of currently running computations. It 			can be in form of a label or some bar. & 
		 &
		1
		\\ \hline	

		9.1 & 
		System will provide a way of monitoring estimated time of all currently running 				computations. It can be in form of a label or some bar. & 
		 &
		1
		\\ \hline

		9.2 & 
		System will provide a way of monitoring estimated time of a particular computation. It 			can be in form of a label or some bar. & 
		 &
		1
		\\ \hline

		10 & 
		By clicking some superior button (like e.g. 'X') user will be able to immediately 				close the application and terminate all computations.  & 
		 &
		1
		\\ \hline
	
		10.1 & 
		By clicking some superior button user will be able to minimize the program. & 
		 &
		2
		\\ \hline	

		10.2 & 
		By grabbing edges user will be able to resize application window. & 
		 &
		3
		\\ \hline
		
	\end{longtable}
\end{center}	


%---------------------------------------------------------------

\newpage

%
% NON_FUNCTIONAL REQUIREMENTS
%
\section{Non Functional Requirements}

%---------------------------------------------------------------
%---------------------------------------------------------------

%
% USABILITY
%
\subsection{Usability} \label{usability}
To begin with, difference between console and GUI application are infinitesimal. Purposes of both are to configure and start new computation along with monitoring currently running ones.
Disparity appears in a way of executing mentioned tasks - GUI will obviously use graphical interface and console will use plain text. This facts implies that GUI will be more user friendly - by its transparency and flexibility. In fact, all user interface elements (like e.g. buttons or checkboxes) will be tightly connected with specific flag in the console application.

%---------------------------------------------------------------
%---------------------------------------------------------------

\subsubsection{GUI}
Optionally GUI should start with welcome screen containing name of the application, simple logo and maybe some short info. Next, main window containing of:
\begin{itemize} 
\item 1 - Panel for new computation configuration
\item 2 - Panel for monitoring of currently running computations
\item 3 - General application 
\end{itemize} 
should be showed. 

From the visual point of view, we would only like user interface elements (like buttons, expandable lists) to be as transparent as possible and easily accessible - no need to hide options in some menus - just straight forward configurations. We also do not force any particular theme of the program - we live you to your own devices in that matter.

%---------------------------------------------------------------
%---------------------------------------------------------------

\subsubsection{Console}
Console is reserved for those who can find their way around in Unix-based systems. Motivation for putting emphasize on the console usage is twofold. Firstly, running our application on a computational cluster might shorten the duration of the computations. In such a case after connecting to remote server, we often times end up without any graphical interface. Instead we have to be able to start the process with command prompt. Lastly, many users of this application might simply prefer the simplicity of the console.

%---------------------------------------------------------------

%
% RELIABILITY
%
\subsection{Reliability}
As in \ref{usability}, differences (if some) are very small. It is again because we want GUI to be somehow higher abstraction layer to the console flags.

%---------------------------------------------------------------
%---------------------------------------------------------------

\subsubsection{GUI}
Any error must be at once reported - either to underneath console or to some part of GUI. In case of any fatal error (like e.g. crash of one of the computations) priority must be given to keep running all the others. As mentioned in section \ref{GUI_func_req} user can choose, which action should be performed after crash - rerunning of the computation or not. 

In addition, because small number of options in Graphical User Interface, we would like to have maximal robustness of all interface elements. Each element should perform its task with non-blocking (considering GUI) routine. In other words, one must be able to e.g. add new computation, while others are being monitored.

What is more, closing GUI during monitoring process must not force computations to stop - all task are continuing their work in background or in visible console windows.

%---------------------------------------------------------------
%---------------------------------------------------------------

\subsubsection{Console}
By console reliability we really mean the actual stability of the algorithms. In this research it is not vital that the computations are perfectly reliable. We assume that if any process fails to finish due to unexpected disk failure, deficiency of memory or any other reason, the computations can be simply restarted at a later time.

%---------------------------------------------------------------

%
% PERRFORMANCE
%
\subsection{Performance}
In this section we will skip subdivision into GUI and Console, because we will focus on the core of the program. Undoubtedly, exact performance of the application will be mainly based on implemented algorithm hence only few remarks will be given.

We want put emphasis on the quality of the results rather than the performance of application itself. The work shall focus on discovering the best possible methods for solving the problem of interest. Having said that, given the nature of complexity of given problem, the computations might take a long time to finish. Thus the developer of the algorithms must be inclined to implement them with reasonable performance.

The usage of many computers should motivate the developers to split the computations into different test benches, thus into different processes. In doing so, multiple processes can be easily run on different computers, thus saving a lot of time. 


%---------------------------------------------------------------

%
% SECURITY AND SAFETY
%
\subsection{Security and Safety}
There is no known internal or external threat.

%---------------------------------------------------------------

\subsection{Risk Analysis}
From our point of view, main risk of this project are poor results from the computations. As we have mentioned, it is a purely research task with usage of methods that have never been used before. 

\end{document}


