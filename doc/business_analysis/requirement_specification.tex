\documentclass{article}

\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage{longtable}
%\usepackage[export]{adjustbox}
%\usepackage{tabu}
\usepackage{xcolor,colortbl}

\begin{document}

\vspace*{3ex}
\begin{flushright}
{\large 3 March 2015}
\end{flushright}

\begin{flushleft}
{\large Jakub Ciecierski\\

}
\end{flushleft}

\hskip3cm

\begin{center}

\Large {\bf
	Cellular automaton
}

\Large {\bf 
	Requirement specification 
}

\vskip2ex

\vspace{60pt}
\includegraphics[width=80mm]{images/mini.PNG} \\
\end{center}

\vskip20ex

\newpage
\tableofcontents
\newpage
\section*{Schedule} \par

\begin{center}

	\begin{tabular}{| l | p{7cm} |}

		\hline
		\cellcolor[HTML]{C0C0C0}Date & \cellcolor[HTML]{C0C0C0} Asset \\
		
		\hline
	  	2015-04-02 & Technical project \\
		
		\hline
	  	2015-04-23 & Code of modules\\
	
		\hline
		2015-04-30 & version 0.98\\

		\hline
		2015-05-07 & version 0.99\\	
		
		\hline
		2015-05-14 & version 1.00\\
		
		\hline
		2015-05-28 & Test report\\
		
		\hline
		2015-06-11 & Acceptation \\
		
		\hline
	
	\end{tabular}

\end{center}

\section*{Document metric}


\begin{table}[h]
\hspace*{-3.1cm}
\large
\begin{tabular}{|
>{\columncolor[HTML]{C0C0C0}}l |l|l|l|l|l|}
\hline
\multicolumn{6}{|l|}{\cellcolor[HTML]{C0C0C0}Document metric}                                                                                                                                         \\ \hline
Project:       & Cellular Automaton                                                       & \cellcolor[HTML]{C0C0C0}Company: & \multicolumn{3}{l|}{WUT}                                               \\ \hline
Name:          & \multicolumn{5}{l|}{Requirement specification}                                                                                                                                       \\ \hline
Topics:        & \multicolumn{5}{l|}{Business analysis of the product}                                                                                                                                       \\ \hline
Author:        & \multicolumn{5}{l|}{Jakub Ciecierski}                                                                                                                                                \\ \hline
File:          & \multicolumn{5}{l|}{requirement\_specification.pdf}                                                                                                                                      \\ \hline
Version no:    & 0.1                                                                      & \cellcolor[HTML]{C0C0C0}Status:  & Under development & \cellcolor[HTML]{C0C0C0}Opening date: & 2015-03-03 \\ \hline
Summary:       & \multicolumn{5}{l|}{Business analysis of application that allows for creating a cellular automaton}                                                                                                           \\ \hline
Authorized by: & \begin{tabular}[c]{@{}l@{}}Władysław Homenda\\ Lucjan Stapp\end{tabular} & \multicolumn{3}{l|}{\cellcolor[HTML]{C0C0C0}Last modification date:}                         & 2015-03-03 \\ \hline
\end{tabular}
\end{table}



\section*{History of changes}

\begin{table}[h]
\hspace*{-2.1cm}
\large
\begin{tabular}{|l|l|l|l|}
\hline
\multicolumn{4}{|l|}{\cellcolor[HTML]{C0C0C0}History of Changes} \\ \hline
Version         & Date         & Who        & Description        \\ \hline
0.1         & 2015-03-03         & Jakub Ciecierski        & Definition of the main purpose of the document       \\ \hline
\end{tabular}
\end{table}

%---------------------------------------------------------------

\newpage
\section{Glossary}


%---------------------------------------------------------------
%---------------------------------------------------------------

\begin{itemize}

\item  {\bf Pattern Recognition}
In broad terms, pattern recognition is science of making assumptions about data using various tools from statistics, machine learning and many others fields.
Focuses on designing and building machines that can recognize patterns. Such patterns can be found in speech, fingerprint, optical characters etc.

Feature is defined as a quality or characteristic of an element.
Such feature can be a symbolic measure (e.g. color) or numeric (e.g. width).
Collection of $d$ features is called a $d$-dimensional feature vector.

In classification a pattern can be represented by a pair $(x,w)$ where $x$ is the feature vector and $w$ is label. A label tells the computer to which class a given element belongs to. Elements from the same class should have similar features, while elements belonging to different classes should have relatively different features.

%---------------------------------------------------------------
%---------------------------------------------------------------

\item {\bf Alphabet}
Is a finite, non empty set of symbols, commonly denoted by $\Sigma$.
Examples of common alphabets:
\begin{enumerate}
	\item $\Sigma$ = $\{0 ,1 \}$ - binary alphabet.
	\item $\Sigma$ = $\{a, b, ..., z\}$ - small letters of latin alphabet.
\end{enumerate}

%---------------------------------------------------------------
%---------------------------------------------------------------

\item {\bf Word over Alphabet}
Also called a \textit{string}, is a sequence of symbols over some alphabet $\Sigma$.
Examples of words:
\begin{enumerate}
	\item A sequence $'01010'$ is a word over binary alphabet $\Sigma=\{0,1\}$.
	\item A word $'lorem'$ is a word over the latin alphabet $\Sigma=\{a, b, ..., z\}$.
\end{enumerate}

An empty word is a word with no symbols. Commonly denoted by $\varepsilon$. Such word can be taken from any alphabet.

A set of all words over alphabet $\Sigma$ is denoted by $\Sigma^*$,
where 
\begin{equation}
\Sigma^* = \Sigma^0 \cup \Sigma^1 \cup \Sigma^2 \cup \Sigma^3 \cup ...
\end{equation}

If $\Sigma = \{0,1\}$
then $\Sigma^0 = \{\varepsilon \}$, $\Sigma^1 = \{0,1\}$ , $\Sigma^2 = \{00, 01 ,10 ,11\}$,
$\Sigma^3 = \{000, 001, 010, 011, 100, 101, 110, 111\}$ and so on

It is important to note that, $\Sigma^*$ is infinite countable set.

%---------------------------------------------------------------
%---------------------------------------------------------------

\item {\bf Language}
Language over alphabet $\Sigma$ will be denoted by L.
Language L is a subset of all words $\Sigma^*$, $L \subseteq \Sigma^*$.

Examples of languages:
\begin{enumerate}

	\item 
	$L = \{\varepsilon, 01, 10, 0011, 0101, 0110, ...\}$ -
	a set of all binary words that have the same number of occurrences of $0's$ 	and $1's$
	
	\item 	$L = \O$ - language is an empty set, contains no words
	
	\item 	$L = \{\varepsilon \}$ - language containing only empty word.

\end{enumerate}


%---------------------------------------------------------------
%---------------------------------------------------------------

\item {\bf Deterministic Finite Automaton (DFA)}
Automaton is a very simply computability model.
It can be thought of as a physical machine containing a \textit{tape} with input word, a \textit{head} reading a single symbol from the tape and finally a steering mechanism which can change its state during the computations based on current state and a symbol that is being read.
DFA computes a word in order to check if a given word belongs to a language accepted by this machine.

Formally DFA is a system of five fields:

\begin{equation}
	A = (Q, \Sigma, \delta, q_0, F)
\end{equation}

where \\
$Q$ - finite set of states. \\
$\Sigma$ - Finite input alphabet. \\
$\delta$ - transition function. $\delta: Q \times \Sigma \rightarrow Q$ \\
$q_0$ - the initial state. $q_0 \in Q$ \\
$F$ - Set of accepting states. $F \subseteq Q$ \\


The computations of DFA is a sequence of transitions based on transition function.
Depending on a state $q$ and symbol $x$ read by the head the machine:
\begin{enumerate}
	\item changes its state to $p \in Q$
	\item moves the head one cell to the right.
\end{enumerate}

Automaton finished computations when all symbols were read. It accepts input if computations end in accepting state, otherwise the input is rejected.



\end{itemize}

%---------------------------------------------------------------

\newpage
\section{Goal}
The main goal of this project is to deploy application, which will create an automaton for given input data. Produced automaton will be a an accurate classifier of objects represented
by the input data. The program is dedicated to reasearch laboratory, hence it is lumbered with the following assuptions.


First of all, all users will be scientists, so precision of calculations and reliability is vital. We want to be sure about results given by the application to such an extent, that they will be publishable. It is also carrying need for specific format of the output - by default latex tables and .xls files. Similarly input is in form of .xls files.


Next thing that we want to stress out is platform and design. As for target system, linux is unquestionable choice. All work stations are running Arch Linux and we want the program to be operable on all of them. Although most of the researchers work inside the laboratory, some of us are using SSH protocol to communicate. This causes the need for plain console application - configurable using flags or simple question/answer scheme. 

But we do not want to limit ourselves only to this approach - finally vast majority of us use computers via the standard X Window System and want to benefit from it. For those who does, we want to present simple GUI based program to configure, run and monitor the process of calculating automata. It will have all functionalites of console part, but will be more easy on the eye and simpler to use for non computer scientist.


Last but not least, we will tackle resources consuption and critical situation handling. On this point let us be clear: we want accurate results - neither time nor memory are important. The assumtion of course holds to some reasonable extent - we do not want to wait a month for program's output, but we are rather used to wait for couple of days. Great solution in this case would be ability to adjust complexity of calculations and, what follows, time needed to complete. With such an estimation, we could easily schedule our work.

\newpage
\section{User stories}

%
% Console / Default User Stories
%
\subsection{Console}
As a user I want to:
\begin{itemize}
	\item 
\end{itemize}

%
% GUI User Stories
%
\subsubsection{GUI}
As a user I want to:
\begin{itemize}
	\item
		load data using file explorer.
	\item
		load data using drag and drop procedure.
	\item
		adjust computation precision and see estimated time to complete.
	\item
		select output format as .xls file.
	\item
		select output format as latex table.
	\item
		select destination folder of the output
	\item
		decide if test should be rerun in case of failure/interruption.
	\item 
		start computation for loaded data.
	\item
		stop specific computation.
	\item
		stop all computations.
	\item 
		monitor number of currently running computations
	\item
		monitor estimated time of all computations
	\item
		monitor progress of single computation.
	\item
		close application at any time
	\item
		minimize application at any time.
	\item 
		resize application window.
\end{itemize}


	

\newpage

\section{Functional Requirements}
In all tables of the following section we assume that priority can take following values:
\begin{itemize} 
\item 1 - must be implemented
\item 2 - can be implemented optionally 
\item 3 - is a nice addition, but not needed.
\end{itemize} 

\subsection{GUI}

\begin{center}
\hspace*{-2.1cm}
	\begin{longtable}{| l | p{4cm} | p{3.5cm} | l |}
	
		\hline
	  	ID & Requirement & Comments & Priority \\
		\hline
		
		1 & 
		The system provides option to load data file using buttun 'Load data' and
		some window explorer to choose a file & 
		 &
		1 
		\\ \hline
		
		1.1 & 
		The system provides area over which one can drag and drop data file.
		Following action will have similar results to requirement of id 1. & 
		 &
		1 
		\\ \hline		
	
		2 & 
		When new data is loaded, one can adjust computation precision via various checkboxes, 			sliders etc. Implementation of this part will depend on used algorithm. & 
		 &
		1 
		\\ \hline		
	
			2.1 & 
		Time estimation indicator, dynamically updated during usage of items from requirement 			of id 2 & 
		 &
		1 
		\\ \hline		
		
		3 & 
		Application will have expanded list with possible output files. Choosing one will 				affect a way of saving result. & 
		 &
		1 
		\\ \hline			

		3.1 & 
		Option of .xls file on list described in 3 & 
		 &
		1 
		\\ \hline		

		3.2 & 
		Option of latex table on list described in 3 & 
		 &
		1 
		\\ \hline	

		4 & 
		System will provide 'Choose Output Folder' button which will open window explorer and 			ask user to choose folder to save result from a test. & 
		 &
		1 
		\\ \hline	
	
		4.1 & 
		Label with path to the output folder, chosen in requirement number 4. & 
		 &
		2 
		\\ \hline		
		
		5 & 
		Opportunity to choose behaviour after crashing of a particular test - rerun or not & 
		 &
		1
		\\ \hline
		
		6 & 
		Button 'Start Computation', which will begin computing automaton for a loaded data. & 
		 &
		1
		\\ \hline		
		
		7 & 
		'Stop Computation' button, for each currently running computation. It will cause 				particular computation to break whatever it is doing right now. & 
		 &
		1
		\\ \hline	
		
		8 & 
		'Stop All Computations' button. All computations break whatever they are doing right 			now. & 
		 &
		1
		\\ \hline		
		
		9 & 
		System will provide a way of monitoring number of currently running computations. It 			can be in form of a label or some bar. & 
		 &
		1
		\\ \hline	

		9.1 & 
		System will provide a way of monitoring estimated time of all currently running 				computations. It can be in form of a label or some bar. & 
		 &
		1
		\\ \hline

		9.2 & 
		System will provide a way of monitoring estimated time of a particular computation. It 			can be in form of a label or some bar. & 
		 &
		1
		\\ \hline

		10 & 
		By clicking some superior button (like e.g. 'X') user will be able to immediately 				close the application and terminate all computations.  & 
		 &
		1
		\\ \hline
	
		10.1 & 
		By clicking some superior button user will be able to minimize the program. & 
		 &
		2
		\\ \hline	

		10.2 & 
		By grabbing edges user will be able to resize application window. & 
		 &
		3
		\\ \hline
		
	\end{longtable}
\end{center}	

\subsection{Console}


\newpage

\section{Non Functional Requirements}
\subsection{Usability}
To begin with, difference between console and GUI application are infinitesimal. Purposes of both are to configure and start new computation along with monitoring currently running ones.
Disparity appears in a way of executing mentioned tasks - GUI will obviously use graphical interface and console will use plain text. This facts implies that GUI will we just more user friendly - by its transparency and flexibility. In fact, all user interface elements (like e.g. buttons or checkboxes) will be tightly connected with specific flag in the console application.

\subsubsection{GUI}
Optionally GUI should start with welcome screen containing name of the application, simple logo and maybe some short info. Next main window, containing of:
\begin{itemize} 
\item 1 - Panel for new computation configuration
\item 2 - Panel for monitoring of currently running computations
\item 3 - General application 
\end{itemize} 


\subsubsection{Console}


\end{document}
